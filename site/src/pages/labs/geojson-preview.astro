---
import Layout from '../../layouts/Layout.astro';

const base = import.meta.env.BASE_URL;
---

<Layout
  title="GeoJSON Preview Map · Labs"
  description="Preview GeoJSON instantly in your browser with a dark MapLibre basemap."
>
  <head>
    <link
      rel="stylesheet"
      href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css"
    />
  </head>

  <header class="lab-hero">
    <p class="lab-kicker">LABS / GEOJSON</p>
    <h1 class="lab-title">GeoJSON Preview Map</h1>
    <p class="lab-subtitle">Preview GeoJSON instantly in your browser.</p>

    <div class="lab-actions">
      <a class="btn secondary" href={`${base}labs/`}>Back to Labs</a>
      <button class="btn ghost" id="sampleBtn" type="button">Load Sample GeoJSON</button>
    </div>
  </header>

  <section class="lab-shell" aria-label="GeoJSON preview workspace">
    <div class="lab-panel">
      <div class="lab-panel__head">
        <div>
          <p class="panel-kicker mono">INPUT MODES</p>
          <h2 class="panel-title">Load your GeoJSON</h2>
        </div>
        <div class="panel-actions">
          <button class="btn secondary" id="exportBtn" type="button">Export</button>
          <button class="btn ghost" id="clearBtn" type="button">Clear</button>
        </div>
      </div>

      <div class="lab-tabs" role="tablist" aria-label="GeoJSON input modes">
        <button
          class="lab-tab active"
          id="tab-paste"
          role="tab"
          aria-selected="true"
          aria-controls="panel-paste"
          type="button"
        >
          Paste
        </button>
        <button
          class="lab-tab"
          id="tab-upload"
          role="tab"
          aria-selected="false"
          aria-controls="panel-upload"
          type="button"
        >
          Upload
        </button>
        <button
          class="lab-tab"
          id="tab-url"
          role="tab"
          aria-selected="false"
          aria-controls="panel-url"
          type="button"
        >
          URL
        </button>
      </div>

      <div class="lab-tabpanels">
        <section
          class="lab-tabpanel active"
          id="panel-paste"
          role="tabpanel"
          aria-labelledby="tab-paste"
          tabindex="0"
        >
          <label class="field-label" for="geojsonInput">Paste GeoJSON</label>
          <textarea
            id="geojsonInput"
            class="lab-textarea"
            rows="10"
            placeholder="{\n  \"type\": \"FeatureCollection\",\n  \"features\": []\n}"
          ></textarea>
          <div class="field-actions">
            <button class="btn cta" id="loadPasteBtn" type="button">Load</button>
          </div>
        </section>

        <section
          class="lab-tabpanel"
          id="panel-upload"
          role="tabpanel"
          aria-labelledby="tab-upload"
          tabindex="0"
        >
          <label class="field-label" for="geojsonFile">Upload GeoJSON file</label>
          <input
            id="geojsonFile"
            class="lab-file"
            type="file"
            accept=".geojson,.json,application/geo+json,application/json"
          />
          <p class="field-hint">
            Supports <span class="mono">.geojson</span> or <span class="mono">.json</span>.
          </p>
        </section>

        <section
          class="lab-tabpanel"
          id="panel-url"
          role="tabpanel"
          aria-labelledby="tab-url"
          tabindex="0"
        >
          <label class="field-label" for="geojsonUrl">Load from URL</label>
          <div class="field-row">
            <input
              id="geojsonUrl"
              class="lab-input"
              type="url"
              placeholder="https://example.com/data.geojson"
            />
            <button class="btn cta" id="loadUrlBtn" type="button">Fetch</button>
          </div>
          <p class="field-hint">
            If CORS blocks the request, download the file and use Upload or paste the contents instead.
          </p>
        </section>
      </div>

      <div class="lab-status" aria-live="polite">
        <div>
          <span class="status-label">Features</span>
          <span id="statusCount">0</span>
        </div>
        <div>
          <span class="status-label">Geometry</span>
          <span id="statusTypes">-</span>
        </div>
        <div>
          <span class="status-label">Extent</span>
          <span id="statusExtent">-</span>
        </div>
        <div class="status-pill" id="statusMessage">Idle</div>
      </div>

      <div class="lab-alert" id="alert" role="alert" hidden></div>
      <div class="lab-warning" id="warning" role="status" hidden></div>
    </div>

    <div class="map-panel" aria-label="Map preview">
      <div id="map" class="map"></div>
      <aside class="info-panel" aria-live="polite">
        <h3 class="info-title">Feature Attributes</h3>
        <pre id="featureInfo" class="info-content">Click a feature to inspect attributes.</pre>
      </aside>
    </div>
  </section>

  <section class="lab-notes">
    <h2 class="notes-title">How it works</h2>
    <ul>
      <li>GeoJSON is normalized into a FeatureCollection before rendering.</li>
      <li>Points, lines, and polygons get distinct dark-mode styles.</li>
      <li>All processing happens locally in your browser.</li>
    </ul>
  </section>

  <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
  <script is:inline>
  // --- Orbit GeoJSON Preview (MapLibre) ---
  // Astro can reorder inline/external scripts, so we:
  // 1) reference MapLibre via window.maplibregl
  // 2) boot only when it's available
  // 3) keep a single shared `map` instance in outer scope

  let map = null;
  let currentCollection = null;

  const geometryGroups = {
    point: ['Point', 'MultiPoint'],
    line: ['LineString', 'MultiLineString'],
    polygon: ['Polygon', 'MultiPolygon'],
  };

  const sampleGeoJSON = {
    type: 'FeatureCollection',
    features: [
      {
        type: 'Feature',
        properties: { name: 'Göteborg', role: 'Sample point' },
        geometry: { type: 'Point', coordinates: [11.9746, 57.7089] },
      },
      {
        type: 'Feature',
        properties: { name: 'Stockholm region', theme: 'Sample polygon' },
        geometry: {
          type: 'Polygon',
          coordinates: [
            [
              [17.7, 59.6],
              [18.6, 59.6],
              [18.6, 59.1],
              [17.7, 59.1],
              [17.7, 59.6],
            ],
          ],
        },
      },
    ],
  };

  // ---- DOM refs (initialized on DOMContentLoaded) ----
  let tabs, panels;
  let alertBox, warningBox;
  let statusCount, statusTypes, statusExtent, statusMessage;
  let featureInfo, geojsonInput, geojsonFile, geojsonUrl;

  const setStatus = (message) => {
    if (statusMessage) statusMessage.textContent = message;
  };

  const showAlert = (message) => {
    if (!alertBox) return;
    alertBox.hidden = false;
    alertBox.textContent = message;
  };

  const showWarning = (message) => {
    if (!warningBox) return;
    warningBox.hidden = false;
    warningBox.textContent = message;
  };

  const clearAlert = () => {
    if (alertBox) {
      alertBox.hidden = true;
      alertBox.textContent = '';
    }
    if (warningBox) {
      warningBox.hidden = true;
      warningBox.textContent = '';
    }
  };

  const resetInfoPanel = () => {
    if (featureInfo) featureInfo.textContent = 'Click a feature to inspect attributes.';
  };

  const formatExtent = (extent) => {
    if (!extent) return '-';
    const [minX, minY, maxX, maxY] = extent;
    return `${minX.toFixed(4)}, ${minY.toFixed(4)} → ${maxX.toFixed(4)}, ${maxY.toFixed(4)}`;
  };

  const summarizeTypes = (features) => {
    const counts = { point: 0, line: 0, polygon: 0, other: 0 };
    features.forEach((feature) => {
      const type = feature?.geometry?.type;
      if (geometryGroups.point.includes(type)) counts.point += 1;
      else if (geometryGroups.line.includes(type)) counts.line += 1;
      else if (geometryGroups.polygon.includes(type)) counts.polygon += 1;
      else counts.other += 1;
    });
    const parts = [];
    if (counts.point) parts.push(`Point ${counts.point}`);
    if (counts.line) parts.push(`Line ${counts.line}`);
    if (counts.polygon) parts.push(`Polygon ${counts.polygon}`);
    if (counts.other) parts.push(`Other ${counts.other}`);
    return parts.length ? parts.join(' · ') : '-';
  };

  const updateStatus = (features, extent) => {
    if (statusCount) statusCount.textContent = String(features.length);
    if (statusTypes) statusTypes.textContent = summarizeTypes(features);
    if (statusExtent) statusExtent.textContent = formatExtent(extent);
  };

  const updateWarningForSize = (featureCount) => {
    if (featureCount > 20000) {
      showWarning(
        `Large dataset detected (${featureCount} features). Consider simplifying your GeoJSON for better performance.`
      );
    }
  };

  // ---- extent helpers (GeoJSON in EPSG:4326) ----
  const collectCoordinates = (coords, list) => {
    if (!coords) return;
    if (typeof coords[0] === 'number' && typeof coords[1] === 'number') {
      list.push(coords);
    } else if (Array.isArray(coords)) {
      coords.forEach((child) => collectCoordinates(child, list));
    }
  };

  const getExtent = (features) => {
    const coords = [];
    features.forEach((feature) => {
      const c = feature?.geometry?.coordinates;
      if (c) collectCoordinates(c, coords);
    });
    if (!coords.length) return null;

    const xs = coords.map((p) => p[0]);
    const ys = coords.map((p) => p[1]);
    return [Math.min(...xs), Math.min(...ys), Math.max(...xs), Math.max(...ys)];
  };

  // ---- normalize input into FeatureCollection ----
  const normalizeGeoJSON = (input) => {
    const warnings = [];
    let features = [];

    if (!input) {
      return { errors: ['No data provided.'], warnings, collection: null };
    }

    if (Array.isArray(input)) {
      // tolerate array of Features
      features = input.filter((item) => item && item.type === 'Feature');
    } else if (input.type === 'FeatureCollection') {
      features = Array.isArray(input.features) ? input.features : [];
    } else if (input.type === 'Feature') {
      features = [input];
    } else if (input.type && 'coordinates' in input) {
      // Geometry
      features = [{ type: 'Feature', properties: {}, geometry: input }];
    }

    const valid = [];
    const invalid = [];

    features.forEach((f) => {
      if (!f || f.type !== 'Feature' || !f.geometry) {
        invalid.push(f);
        return;
      }
      valid.push({
        type: 'Feature',
        properties: f.properties || {},
        geometry: f.geometry,
      });
    });

    if (invalid.length) {
      warnings.push(`Skipped ${invalid.length} feature(s) without geometry.`);
    }

    if (!valid.length) {
      return { errors: ['No valid GeoJSON features were found.'], warnings, collection: null };
    }

    return {
      errors: [],
      warnings,
      collection: { type: 'FeatureCollection', features: valid },
    };
  };

  // ---- Map rendering ----
  const ensureGeoJSONLayers = () => {
    if (!map) return;

    if (!map.getSource('geojson')) {
      map.addSource('geojson', {
        type: 'geojson',
        data: { type: 'FeatureCollection', features: [] },
      });

      map.addLayer({
        id: 'geojson-fill',
        type: 'fill',
        source: 'geojson',
        filter: ['in', ['geometry-type'], ['literal', geometryGroups.polygon]],
        paint: {
          'fill-color': 'rgba(88,166,255,0.25)',
          'fill-outline-color': 'rgba(88,166,255,0.7)',
        },
      });

      map.addLayer({
        id: 'geojson-line',
        type: 'line',
        source: 'geojson',
        filter: ['in', ['geometry-type'], ['literal', geometryGroups.line]],
        paint: {
          'line-color': 'rgba(160,214,255,0.85)',
          'line-width': 2,
        },
      });

      map.addLayer({
        id: 'geojson-point',
        type: 'circle',
        source: 'geojson',
        filter: ['in', ['geometry-type'], ['literal', geometryGroups.point]],
        paint: {
          'circle-color': 'rgba(246,217,110,0.92)',
          'circle-stroke-color': 'rgba(12,18,30,0.85)',
          'circle-stroke-width': 1.2,
          'circle-radius': 6,
        },
      });

      const bindLayerEvents = (layerId) => {
        map.on('mouseenter', layerId, () => (map.getCanvas().style.cursor = 'pointer'));
        map.on('mouseleave', layerId, () => (map.getCanvas().style.cursor = ''));

        map.on('click', layerId, (event) => {
          const feature = event.features?.[0];
          if (!feature) return;
          const props = feature.properties || {};
          const content = Object.keys(props).length ? JSON.stringify(props, null, 2) : 'No attributes';
          if (featureInfo) featureInfo.textContent = content;
        });
      };

      ['geojson-fill', 'geojson-line', 'geojson-point'].forEach(bindLayerEvents);
    }
  };

  const renderGeoJSON = (collection) => {
    if (!map) return;
    ensureGeoJSONLayers();
    const src = map.getSource('geojson');
    if (src) src.setData(collection);
  };

  const removeGeoJSON = () => {
    if (!map) return;

    // Remove layers first
    if (map.getLayer('geojson-point')) map.removeLayer('geojson-point');
    if (map.getLayer('geojson-line')) map.removeLayer('geojson-line');
    if (map.getLayer('geojson-fill')) map.removeLayer('geojson-fill');

    // Then source
    if (map.getSource('geojson')) map.removeSource('geojson');
  };

  const fitToExtent = (extent) => {
    if (!map || !extent) return;
    map.fitBounds(
      [
        [extent[0], extent[1]],
        [extent[2], extent[3]],
      ],
      { padding: 60, duration: 650 }
    );
  };

  // ---- Load handlers ----
  const handleGeoJSON = (payload, sourceLabel = 'Loaded') => {
    clearAlert();
    resetInfoPanel();

    if (!map) {
      showAlert('Map is not ready yet. Try again in a moment.');
      setStatus('Loading');
      return;
    }

    const { errors, warnings, collection } = normalizeGeoJSON(payload);
    if (errors.length) {
      showAlert(errors.join(' '));
      setStatus('Error');
      return;
    }

    warnings.forEach((w) => showWarning(w));
    updateWarningForSize(collection.features.length);

    currentCollection = collection;
    renderGeoJSON(collection);

    const extent = getExtent(collection.features);
    updateStatus(collection.features, extent);
    fitToExtent(extent);

    setStatus(sourceLabel);
  };

  const handleTextInput = (text, sourceLabel) => {
    if (!text.trim()) {
      showAlert('Please provide GeoJSON before loading.');
      setStatus('Idle');
      return;
    }

    let parsed;
    try {
      parsed = JSON.parse(text);
    } catch (error) {
      showAlert(`JSON parse error: ${error.message}`);
      setStatus('Error');
      return;
    }

    handleGeoJSON(parsed, sourceLabel);
  };

  const loadFromFile = (file) => {
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (event) => {
      const text = event.target?.result || '';
      handleTextInput(String(text), 'File loaded');
    };
    reader.onerror = () => {
      showAlert('Unable to read the selected file.');
      setStatus('Error');
    };
    reader.readAsText(file);
  };

  const loadFromUrl = async () => {
    const url = geojsonUrl?.value?.trim() || '';
    if (!url) {
      showAlert('Please enter a URL to fetch.');
      setStatus('Idle');
      return;
    }

    setStatus('Fetching');
    clearAlert();

    try {
      const response = await fetch(url, { mode: 'cors' });
      if (!response.ok) {
        showAlert(`Fetch failed with status ${response.status} ${response.statusText}.`);
        setStatus('Error');
        return;
      }
      const text = await response.text();
      handleTextInput(text, 'URL loaded');
    } catch (error) {
      const fallbackMessage =
        error instanceof TypeError
          ? 'CORS blocked the request. Download the file and use Upload, or paste the contents.'
          : 'Network error while fetching the URL.';
      showAlert(`${fallbackMessage} (${error?.name || 'Error'})`);
      setStatus('Error');
    }
  };

  const downloadCollection = () => {
    clearAlert();
    if (!currentCollection) {
      showAlert('Nothing to export yet. Load GeoJSON first.');
      setStatus('Idle');
      return;
    }
    const blob = new Blob([JSON.stringify(currentCollection, null, 2)], {
      type: 'application/geo+json',
    });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = 'data.geojson';
    document.body.appendChild(link);
    link.click();
    link.remove();
    setTimeout(() => URL.revokeObjectURL(url), 500);
  };

  const clearAll = () => {
    removeGeoJSON();
    currentCollection = null;

    if (geojsonInput) geojsonInput.value = '';
    if (geojsonFile) geojsonFile.value = '';
    if (geojsonUrl) geojsonUrl.value = '';

    updateStatus([], null);
    clearAlert();
    resetInfoPanel();
    setStatus('Idle');

    if (map) map.easeTo({ center: [15.0, 62.0], zoom: 4, duration: 400 });
  };

  const switchTab = (tab) => {
    tabs.forEach((btn) => {
      btn.classList.toggle('active', btn === tab);
      btn.setAttribute('aria-selected', btn === tab ? 'true' : 'false');
    });
    panels.forEach((panel) => {
      panel.classList.toggle('active', panel.id === tab.getAttribute('aria-controls'));
    });
    tab.focus();
  };

  // ---- Boot sequence ----
  const initUI = () => {
    tabs = Array.from(document.querySelectorAll('.lab-tab'));
    panels = Array.from(document.querySelectorAll('.lab-tabpanel'));

    alertBox = document.getElementById('alert');
    warningBox = document.getElementById('warning');
    statusCount = document.getElementById('statusCount');
    statusTypes = document.getElementById('statusTypes');
    statusExtent = document.getElementById('statusExtent');
    statusMessage = document.getElementById('statusMessage');
    featureInfo = document.getElementById('featureInfo');

    geojsonInput = document.getElementById('geojsonInput');
    geojsonFile = document.getElementById('geojsonFile');
    geojsonUrl = document.getElementById('geojsonUrl');

    // Tabs
    tabs.forEach((tab) => {
      tab.addEventListener('click', () => switchTab(tab));
      tab.addEventListener('keydown', (event) => {
        if (!['ArrowLeft', 'ArrowRight'].includes(event.key)) return;
        event.preventDefault();
        const currentIndex = tabs.indexOf(tab);
        const nextIndex =
          event.key === 'ArrowRight'
            ? (currentIndex + 1) % tabs.length
            : (currentIndex - 1 + tabs.length) % tabs.length;
        switchTab(tabs[nextIndex]);
      });
    });

    // Buttons
    document.getElementById('loadPasteBtn')?.addEventListener('click', () => {
      handleTextInput(geojsonInput?.value || '', 'Paste loaded');
    });

    document.getElementById('loadUrlBtn')?.addEventListener('click', () => {
      loadFromUrl();
    });

    document.getElementById('sampleBtn')?.addEventListener('click', () => {
      if (geojsonInput) geojsonInput.value = JSON.stringify(sampleGeoJSON, null, 2);
      const pasteTab = document.getElementById('tab-paste');
      if (pasteTab) switchTab(pasteTab);
      handleGeoJSON(sampleGeoJSON, 'Sample loaded');
    });

    document.getElementById('exportBtn')?.addEventListener('click', downloadCollection);
    document.getElementById('clearBtn')?.addEventListener('click', clearAll);

    geojsonFile?.addEventListener('change', (event) => {
      const file = event.target?.files?.[0];
      loadFromFile(file);
    });

    // Initial state
    updateStatus([], null);
    setStatus('Loading');
    resetInfoPanel();
  };

  const initMapWhenReady = () => {
    const maplibregl = window.maplibregl;
    if (!maplibregl) {
      // Astro can run inline scripts before external scripts execute.
      setTimeout(initMapWhenReady, 25);
      return;
    }

    // Create map once
    if (map) return;

    map = new maplibregl.Map({
      container: 'map',
      style: {
        version: 8,
        sources: {
          dark: {
            type: 'raster',
            tiles: ['https://basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png'],
            tileSize: 256,
            attribution:
              '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
          },
        },
        layers: [{ id: 'dark', type: 'raster', source: 'dark' }],
      },
      center: [15.0, 62.0],
      zoom: 4,
      maxZoom: 18,
    });

    map.addControl(new maplibregl.NavigationControl({ showCompass: false }));

    map.on('load', () => {
      setStatus('Idle');
    });
  };

  const boot = () => {
    initUI();
    initMapWhenReady();
  };

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', boot);
  } else {
    boot();
  }
</script>
</Layout>

<style>
.lab-hero{
  text-align: center;
  padding: var(--spacing-xl) 0 var(--spacing-lg);
}
.lab-kicker{
  font-family: var(--font-mono);
  font-size: 0.78rem;
  letter-spacing: 0.16em;
  text-transform: uppercase;
  color: rgba(88,166,255,0.8);
  margin-bottom: 8px;
}
.lab-title{
  margin: 0 0 8px;
  font-family: var(--font-display);
  letter-spacing: 0.03em;
}
.lab-subtitle{
  margin: 0 auto;
  color: rgba(230,237,243,0.72);
  max-width: 60ch;
}
.lab-actions{
  margin-top: var(--spacing-md);
  display: flex;
  justify-content: center;
  gap: 12px;
  flex-wrap: wrap;
}

.lab-shell{
  display: grid;
  grid-template-columns: minmax(280px, 420px) 1fr;
  gap: var(--spacing-lg);
  align-items: start;
}
@media (max-width: 980px){
  .lab-shell{ grid-template-columns: 1fr; }
}

.lab-panel{
  border-radius: 18px;
  border: 1px solid rgba(255,255,255,0.08);
  background: rgba(13,17,23,0.55);
  padding: var(--spacing-md);
  box-shadow: 0 20px 55px rgba(0,0,0,0.28);
}
.lab-panel__head{
  display: flex;
  gap: 12px;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
}
.panel-kicker{
  font-size: 0.7rem;
  letter-spacing: 0.18em;
  text-transform: uppercase;
  color: rgba(88,166,255,0.72);
  margin: 0 0 6px;
}
.panel-title{
  margin: 0;
  font-size: 1.2rem;
}
.panel-actions{ display:flex; gap: 8px; flex-wrap: wrap; }

.lab-tabs{
  display: flex;
  gap: 8px;
  margin-top: var(--spacing-md);
  flex-wrap: wrap;
}
.lab-tab{
  border: 1px solid rgba(88,166,255,0.2);
  background: rgba(13,17,23,0.3);
  color: rgba(230,237,243,0.7);
  padding: 6px 12px;
  border-radius: 999px;
  cursor: pointer;
  font-size: 0.7rem;
  letter-spacing: 0.12em;
  text-transform: uppercase;
}
.lab-tab.active{
  border-color: rgba(88,166,255,0.4);
  color: rgba(88,166,255,0.95);
}

.lab-tabpanels{
  margin-top: var(--spacing-md);
}
.lab-tabpanel{ display: none; }
.lab-tabpanel.active{ display: block; }

.field-label{
  display: block;
  font-weight: 600;
  margin-bottom: 6px;
}
.lab-textarea{
  width: 100%;
  background: rgba(13,17,23,0.4);
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 12px;
  padding: 12px;
  color: rgba(230,237,243,0.9);
  font-family: var(--font-mono);
}
.lab-input,
.lab-file{
  width: 100%;
  background: rgba(13,17,23,0.4);
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 12px;
  padding: 10px 12px;
  color: rgba(230,237,243,0.9);
}
.field-row{
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}
.field-row .lab-input{ flex: 1 1 220px; }
.field-actions{ margin-top: 10px; }
.field-hint{
  margin-top: 8px;
  color: rgba(230,237,243,0.55);
  font-size: 0.85rem;
}

.lab-status{
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
  gap: 8px;
  margin-top: var(--spacing-md);
  padding: 12px;
  border-radius: 14px;
  border: 1px solid rgba(88,166,255,0.16);
  background: rgba(13,17,23,0.35);
  font-size: 0.85rem;
}
.status-label{
  display: block;
  color: rgba(88,166,255,0.72);
  font-size: 0.7rem;
  letter-spacing: 0.12em;
  text-transform: uppercase;
}
.status-pill{
  align-self: center;
  justify-self: end;
  padding: 4px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.1);
  background: rgba(13,17,23,0.3);
  text-transform: uppercase;
  letter-spacing: 0.12em;
  font-size: 0.7rem;
}

.lab-alert,
.lab-warning{
  margin-top: 12px;
  padding: 12px;
  border-radius: 12px;
  border: 1px solid rgba(255, 90, 90, 0.3);
  background: rgba(120, 20, 20, 0.2);
  color: rgba(255, 200, 200, 0.9);
  font-size: 0.9rem;
}
.lab-warning{
  border-color: rgba(246, 217, 110, 0.4);
  background: rgba(60, 50, 18, 0.35);
  color: rgba(246, 217, 110, 0.92);
}

.map-panel{
  position: relative;
  border-radius: 18px;
  overflow: hidden;
  border: 1px solid rgba(255,255,255,0.08);
  background: rgba(13,17,23,0.5);
  min-height: 520px;
}
.map{
  width: 100%;
  height: 520px;
}
.info-panel{
  position: absolute;
  right: 16px;
  bottom: 16px;
  max-width: 320px;
  background: rgba(13,17,23,0.82);
  border: 1px solid rgba(88,166,255,0.2);
  border-radius: 14px;
  padding: 12px;
  color: rgba(230,237,243,0.85);
  box-shadow: 0 12px 40px rgba(0,0,0,0.35);
}
.info-title{
  margin: 0 0 6px;
  font-size: 0.85rem;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: rgba(88,166,255,0.8);
}
.info-content{
  margin: 0;
  max-height: 240px;
  overflow: auto;
  font-size: 0.8rem;
  white-space: pre-wrap;
}

.lab-notes{
  margin-top: var(--spacing-xl);
  border-radius: 16px;
  border: 1px solid rgba(255,255,255,0.08);
  background: rgba(13,17,23,0.45);
  padding: var(--spacing-md);
}
.notes-title{
  margin-top: 0;
  font-size: 1.1rem;
}
</style>