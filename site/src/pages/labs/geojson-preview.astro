---
import Layout from '../../layouts/Layout.astro';

const base = import.meta.env.BASE_URL;
---

<Layout
  title="GeoJSON Preview Map · Labs"
  description="Preview GeoJSON instantly in your browser with a dark MapLibre basemap."
>
  <head>
    <link
      rel="stylesheet"
      href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css"
    />
  </head>

  <header class="lab-hero">
    <p class="lab-kicker">LABS / GEOJSON</p>
    <h1 class="lab-title">GeoJSON Preview Map</h1>
    <p class="lab-subtitle">Preview GeoJSON instantly in your browser.</p>

    <div class="lab-actions">
      <a class="btn secondary" href={`${base}labs/`}>Back to Labs</a>
      <button class="btn ghost" id="sampleBtn" type="button">Load Sample GeoJSON</button>
    </div>
  </header>

  <section class="lab-shell" aria-label="GeoJSON preview workspace">
    <div class="lab-panel">
      <div class="lab-panel__head">
        <div>
          <p class="panel-kicker mono">INPUT MODES</p>
          <h2 class="panel-title">Load your GeoJSON</h2>
        </div>
        <div class="panel-actions">
          <button class="btn secondary" id="exportBtn" type="button">Export</button>
          <button class="btn ghost" id="clearBtn" type="button">Clear</button>
        </div>
      </div>

      <div class="lab-tabs" role="tablist" aria-label="GeoJSON input modes">
        <button
          class="lab-tab active"
          id="tab-paste"
          role="tab"
          aria-selected="true"
          aria-controls="panel-paste"
          type="button"
        >
          Paste
        </button>
        <button
          class="lab-tab"
          id="tab-upload"
          role="tab"
          aria-selected="false"
          aria-controls="panel-upload"
          type="button"
        >
          Upload
        </button>
        <button
          class="lab-tab"
          id="tab-url"
          role="tab"
          aria-selected="false"
          aria-controls="panel-url"
          type="button"
        >
          URL
        </button>
      </div>

      <div class="lab-tabpanels">
        <section
          class="lab-tabpanel active"
          id="panel-paste"
          role="tabpanel"
          aria-labelledby="tab-paste"
          tabindex="0"
        >
          <label class="field-label" for="geojsonInput">Paste GeoJSON</label>
          <textarea
            id="geojsonInput"
            class="lab-textarea"
            rows="10"
            placeholder="{\n  \"type\": \"FeatureCollection\",\n  \"features\": []\n}"
          ></textarea>
          <div class="field-actions">
            <button class="btn cta" id="loadPasteBtn" type="button">Load</button>
          </div>
        </section>

        <section
          class="lab-tabpanel"
          id="panel-upload"
          role="tabpanel"
          aria-labelledby="tab-upload"
          tabindex="0"
        >
          <label class="field-label" for="geojsonFile">Upload GeoJSON file</label>
          <input
            id="geojsonFile"
            class="lab-file"
            type="file"
            accept=".geojson,.json,application/geo+json,application/json"
          />
          <p class="field-hint">
            Supports <span class="mono">.geojson</span> or <span class="mono">.json</span>.
          </p>
        </section>

        <section
          class="lab-tabpanel"
          id="panel-url"
          role="tabpanel"
          aria-labelledby="tab-url"
          tabindex="0"
        >
          <label class="field-label" for="geojsonUrl">Load from URL</label>
          <div class="field-row">
            <input
              id="geojsonUrl"
              class="lab-input"
              type="url"
              placeholder="https://example.com/data.geojson"
            />
            <button class="btn cta" id="loadUrlBtn" type="button">Fetch</button>
          </div>
          <p class="field-hint">
            If CORS blocks the request, download the file and use Upload or paste the contents instead.
          </p>
        </section>
      </div>

      <div class="lab-status" aria-live="polite">
        <div>
          <span class="status-label">Features</span>
          <span id="statusCount">0</span>
        </div>
        <div>
          <span class="status-label">Geometry</span>
          <span id="statusTypes">-</span>
        </div>
        <div>
          <span class="status-label">Extent</span>
          <span id="statusExtent">-</span>
        </div>
        <div class="status-pill" id="statusMessage">Idle</div>
      </div>

      <div class="lab-alert" id="alert" role="alert" hidden></div>
      <div class="lab-warning" id="warning" role="status" hidden></div>
    </div>

    <div class="map-panel" aria-label="Map preview">
      <div id="map" class="map"></div>
      <aside class="info-panel" aria-live="polite">
        <h3 class="info-title">Feature Attributes</h3>
        <pre id="featureInfo" class="info-content">Click a feature to inspect attributes.</pre>
      </aside>
    </div>
  </section>

  <section class="lab-notes">
    <h2 class="notes-title">How it works</h2>
    <ul>
      <li>GeoJSON is normalized into a FeatureCollection before rendering.</li>
      <li>Points, lines, and polygons get distinct dark-mode styles.</li>
      <li>All processing happens locally in your browser.</li>
    </ul>
  </section>

  <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js" defer></script>
  <script is:inline>
    window.addEventListener('load', () => {
    const map = new maplibregl.Map({
      container: 'map',
      style: {
        version: 8,
        sources: {
          dark: {
            type: 'raster',
            tiles: [
              'https://basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png',
            ],
            tileSize: 256,
            attribution:
              '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
          },
        },
        layers: [
          {
            id: 'dark',
            type: 'raster',
            source: 'dark',
          },
        ],
      },
      center: [15.0, 62.0],
      zoom: 4,
      maxZoom: 18,
    });

    map.addControl(new maplibregl.NavigationControl({ showCompass: false }));

    const tabs = Array.from(document.querySelectorAll('.lab-tab'));
    const panels = Array.from(document.querySelectorAll('.lab-tabpanel'));
    const alertBox = document.getElementById('alert');
    const warningBox = document.getElementById('warning');
    const statusCount = document.getElementById('statusCount');
    const statusTypes = document.getElementById('statusTypes');
    const statusExtent = document.getElementById('statusExtent');
    const statusMessage = document.getElementById('statusMessage');
    const featureInfo = document.getElementById('featureInfo');
    const geojsonInput = document.getElementById('geojsonInput');
    const geojsonFile = document.getElementById('geojsonFile');
    const geojsonUrl = document.getElementById('geojsonUrl');
    let currentCollection = null;

    const sampleGeoJSON = {
      type: 'FeatureCollection',
      features: [
        {
          type: 'Feature',
          properties: { name: 'Göteborg', role: 'Sample point' },
          geometry: {
            type: 'Point',
            coordinates: [11.9746, 57.7089],
          },
        },
        {
          type: 'Feature',
          properties: { name: 'Stockholm region', theme: 'Sample polygon' },
          geometry: {
            type: 'Polygon',
            coordinates: [
              [
                [17.7, 59.6],
                [18.6, 59.6],
                [18.6, 59.1],
                [17.7, 59.1],
                [17.7, 59.6],
              ],
            ],
          },
        },
      ],
    };

    const geometryGroups = {
      point: ['Point', 'MultiPoint'],
      line: ['LineString', 'MultiLineString'],
      polygon: ['Polygon', 'MultiPolygon'],
    };

    const setStatus = (message) => {
      statusMessage.textContent = message;
    };

    const showAlert = (message) => {
      alertBox.hidden = false;
      alertBox.textContent = message;
    };

    const showWarning = (message) => {
      warningBox.hidden = false;
      warningBox.textContent = message;
    };

    const clearAlert = () => {
      alertBox.hidden = true;
      alertBox.textContent = '';
      warningBox.hidden = true;
      warningBox.textContent = '';
    };

    const formatExtent = (extent) => {
      if (!extent) return '-';
      const [minX, minY, maxX, maxY] = extent;
      return `${minX.toFixed(4)}, ${minY.toFixed(4)} → ${maxX.toFixed(4)}, ${maxY.toFixed(4)}`;
    };

    const collectCoordinates = (coords, list) => {
      if (typeof coords[0] === 'number') {
        list.push(coords);
      } else {
        coords.forEach((child) => collectCoordinates(child, list));
      }
    };

    const getExtent = (features) => {
      const coords = [];
      features.forEach((feature) => {
        if (!feature || !feature.geometry) return;
        collectCoordinates(feature.geometry.coordinates, coords);
      });

      if (!coords.length) return null;

      const xs = coords.map((coord) => coord[0]);
      const ys = coords.map((coord) => coord[1]);
      return [Math.min(...xs), Math.min(...ys), Math.max(...xs), Math.max(...ys)];
    };

    // Normalize FeatureCollection/Feature/Geometry into a single FeatureCollection.
    const normalizeGeoJSON = (input) => {
      const warnings = [];
      let features = [];

      if (!input) {
        return { errors: ['No data provided.'], warnings, collection: null };
      }

      if (Array.isArray(input)) {
        features = input.filter((item) => item && item.type === 'Feature');
      } else if (input.type === 'FeatureCollection') {
        features = Array.isArray(input.features) ? input.features : [];
      } else if (input.type === 'Feature') {
        features = [input];
      } else if (input.type && input.coordinates) {
        features = [{ type: 'Feature', properties: {}, geometry: input }];
      }

      const validFeatures = [];
      const invalidFeatures = [];

      features.forEach((feature) => {
        if (!feature || feature.type !== 'Feature') {
          invalidFeatures.push(feature);
          return;
        }
        if (!feature.geometry) {
          invalidFeatures.push(feature);
          return;
        }
        validFeatures.push({
          type: 'Feature',
          properties: feature.properties || {},
          geometry: feature.geometry,
        });
      });

      if (invalidFeatures.length) {
        warnings.push(`Skipped ${invalidFeatures.length} feature(s) without geometry.`);
      }

      if (!validFeatures.length) {
        return { errors: ['No valid GeoJSON features were found.'], warnings, collection: null };
      }

      return {
        errors: [],
        warnings,
        collection: {
          type: 'FeatureCollection',
          features: validFeatures,
        },
      };
    };

    const summarizeTypes = (features) => {
      const counts = { point: 0, line: 0, polygon: 0, other: 0 };
      features.forEach((feature) => {
        const type = feature.geometry?.type;
        if (geometryGroups.point.includes(type)) counts.point += 1;
        else if (geometryGroups.line.includes(type)) counts.line += 1;
        else if (geometryGroups.polygon.includes(type)) counts.polygon += 1;
        else counts.other += 1;
      });
      const parts = [];
      if (counts.point) parts.push(`Point ${counts.point}`);
      if (counts.line) parts.push(`Line ${counts.line}`);
      if (counts.polygon) parts.push(`Polygon ${counts.polygon}`);
      if (counts.other) parts.push(`Other ${counts.other}`);
      return parts.length ? parts.join(' · ') : '-';
    };

    const updateStatus = (features, extent) => {
      statusCount.textContent = features.length.toString();
      statusTypes.textContent = summarizeTypes(features);
      statusExtent.textContent = formatExtent(extent);
    };

    const updateWarningForSize = (featureCount) => {
      if (featureCount > 20000) {
        showWarning(
          `Large dataset detected (${featureCount} features). Consider simplifying your GeoJSON for better performance.`
        );
      }
    };

    const resetInfoPanel = () => {
      featureInfo.textContent = 'Click a feature to inspect attributes.';
    };

    const renderGeoJSON = (collection) => {
      if (!map.getSource('geojson')) {
        map.addSource('geojson', {
          type: 'geojson',
          data: collection,
        });

        map.addLayer({
          id: 'geojson-fill',
          type: 'fill',
          source: 'geojson',
          filter: ['in', ['geometry-type'], ['literal', geometryGroups.polygon]],
          paint: {
            'fill-color': 'rgba(88,166,255,0.25)',
            'fill-outline-color': 'rgba(88,166,255,0.7)',
          },
        });

        map.addLayer({
          id: 'geojson-line',
          type: 'line',
          source: 'geojson',
          filter: ['in', ['geometry-type'], ['literal', geometryGroups.line]],
          paint: {
            'line-color': 'rgba(160, 214, 255, 0.85)',
            'line-width': 2,
          },
        });

        map.addLayer({
          id: 'geojson-point',
          type: 'circle',
          source: 'geojson',
          filter: ['in', ['geometry-type'], ['literal', geometryGroups.point]],
          paint: {
            'circle-color': 'rgba(246, 217, 110, 0.92)',
            'circle-stroke-color': 'rgba(12, 18, 30, 0.85)',
            'circle-stroke-width': 1.2,
            'circle-radius': 6,
          },
        });

        ['geojson-fill', 'geojson-line', 'geojson-point'].forEach((layer) => {
          map.on('mouseenter', layer, () => {
            map.getCanvas().style.cursor = 'pointer';
          });
          map.on('mouseleave', layer, () => {
            map.getCanvas().style.cursor = '';
          });
          map.on('click', layer, (event) => {
            const feature = event.features?.[0];
            if (!feature) return;
            const props = feature.properties || {};
            const content = Object.keys(props).length
              ? JSON.stringify(props, null, 2)
              : 'No attributes';
            featureInfo.textContent = content;
          });
        });
      } else {
        map.getSource('geojson').setData(collection);
      }
    };

    const removeGeoJSON = () => {
      if (map.getLayer('geojson-point')) map.removeLayer('geojson-point');
      if (map.getLayer('geojson-line')) map.removeLayer('geojson-line');
      if (map.getLayer('geojson-fill')) map.removeLayer('geojson-fill');
      if (map.getSource('geojson')) map.removeSource('geojson');
    };

    // Zoom to the data extent after render.
    const fitToExtent = (extent) => {
      if (!extent) return;
      map.fitBounds(
        [
          [extent[0], extent[1]],
          [extent[2], extent[3]],
        ],
        { padding: 60, duration: 650 }
      );
    };

    const handleGeoJSON = (payload, sourceLabel = 'Loaded') => {
      clearAlert();
      resetInfoPanel();

      const { errors, warnings, collection } = normalizeGeoJSON(payload);
      if (errors.length) {
        showAlert(errors.join(' '));
        setStatus('Error');
        return;
      }

      warnings.forEach((warning) => showWarning(warning));
      updateWarningForSize(collection.features.length);

      currentCollection = collection;
      renderGeoJSON(collection);
      const extent = getExtent(collection.features);
      updateStatus(collection.features, extent);
      fitToExtent(extent);
      setStatus(sourceLabel);
    };

    const handleTextInput = (text, sourceLabel) => {
      if (!text.trim()) {
        showAlert('Please provide GeoJSON before loading.');
        setStatus('Idle');
        return;
      }

      let parsed;
      try {
        parsed = JSON.parse(text);
      } catch (error) {
        showAlert(`JSON parse error: ${error.message}`);
        setStatus('Error');
        return;
      }

      handleGeoJSON(parsed, sourceLabel);
    };

    const loadFromFile = (file) => {
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (event) => {
        const text = event.target?.result || '';
        handleTextInput(String(text), 'File loaded');
      };
      reader.onerror = () => {
        showAlert('Unable to read the selected file.');
        setStatus('Error');
      };
      reader.readAsText(file);
    };

    const loadFromUrl = async () => {
      const url = geojsonUrl.value.trim();
      if (!url) {
        showAlert('Please enter a URL to fetch.');
        setStatus('Idle');
        return;
      }

      setStatus('Fetching');
      clearAlert();

      try {
        const response = await fetch(url, { mode: 'cors' });
        if (!response.ok) {
          showAlert(`Fetch failed with status ${response.status} ${response.statusText}.`);
          setStatus('Error');
          return;
        }
        const text = await response.text();
        handleTextInput(text, 'URL loaded');
      } catch (error) {
        // CORS/network errors surface as TypeError; guide the user to other inputs.
        const fallbackMessage =
          error instanceof TypeError
            ? 'CORS blocked the request. Download the file and use Upload, or paste the contents.'
            : 'Network error while fetching the URL.';
        showAlert(
          `${fallbackMessage} (${error?.name || 'Error'})`
        );
        setStatus('Error');
      }
    };

    const downloadCollection = () => {
      if (!currentCollection) {
        showAlert('Nothing to export yet. Load GeoJSON first.');
        setStatus('Idle');
        return;
      }
      const blob = new Blob([JSON.stringify(currentCollection, null, 2)], {
        type: 'application/geo+json',
      });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = 'data.geojson';
      link.click();
      URL.revokeObjectURL(url);
    };

    const clearAll = () => {
      removeGeoJSON();
      currentCollection = null;
      geojsonInput.value = '';
      geojsonFile.value = '';
      geojsonUrl.value = '';
      updateStatus([], null);
      clearAlert();
      resetInfoPanel();
      setStatus('Idle');
      map.easeTo({ center: [15.0, 62.0], zoom: 4, duration: 400 });
    };

    const switchTab = (tab) => {
      tabs.forEach((btn) => {
        btn.classList.toggle('active', btn === tab);
        btn.setAttribute('aria-selected', btn === tab);
      });
      panels.forEach((panel) => {
        panel.classList.toggle('active', panel.id === tab.getAttribute('aria-controls'));
      });
      tab.focus();
    };

    tabs.forEach((tab) => {
      tab.addEventListener('click', () => switchTab(tab));
      tab.addEventListener('keydown', (event) => {
        if (!['ArrowLeft', 'ArrowRight'].includes(event.key)) return;
        event.preventDefault();
        const currentIndex = tabs.indexOf(tab);
        const nextIndex = event.key === 'ArrowRight'
          ? (currentIndex + 1) % tabs.length
          : (currentIndex - 1 + tabs.length) % tabs.length;
        switchTab(tabs[nextIndex]);
      });
    });

    document.getElementById('loadPasteBtn').addEventListener('click', () => {
      handleTextInput(geojsonInput.value, 'Paste loaded');
    });

    document.getElementById('loadUrlBtn').addEventListener('click', () => {
      loadFromUrl();
    });

    document.getElementById('sampleBtn').addEventListener('click', () => {
      geojsonInput.value = JSON.stringify(sampleGeoJSON, null, 2);
      switchTab(document.getElementById('tab-paste'));
      handleGeoJSON(sampleGeoJSON, 'Sample loaded');
    });

    document.getElementById('exportBtn').addEventListener('click', downloadCollection);
    document.getElementById('clearBtn').addEventListener('click', clearAll);

    geojsonFile.addEventListener('change', (event) => {
      const file = event.target.files?.[0];
      loadFromFile(file);
    });

    map.on('load', () => {
      setStatus('Idle');
    });
    });
  </script>
</Layout>

<style>
.lab-hero{
  text-align: center;
  padding: var(--spacing-xl) 0 var(--spacing-lg);
}
.lab-kicker{
  font-family: var(--font-mono);
  font-size: 0.78rem;
  letter-spacing: 0.16em;
  text-transform: uppercase;
  color: rgba(88,166,255,0.8);
  margin-bottom: 8px;
}
.lab-title{
  margin: 0 0 8px;
  font-family: var(--font-display);
  letter-spacing: 0.03em;
}
.lab-subtitle{
  margin: 0 auto;
  color: rgba(230,237,243,0.72);
  max-width: 60ch;
}
.lab-actions{
  margin-top: var(--spacing-md);
  display: flex;
  justify-content: center;
  gap: 12px;
  flex-wrap: wrap;
}

.lab-shell{
  display: grid;
  grid-template-columns: minmax(280px, 420px) 1fr;
  gap: var(--spacing-lg);
  align-items: start;
}
@media (max-width: 980px){
  .lab-shell{ grid-template-columns: 1fr; }
}

.lab-panel{
  border-radius: 18px;
  border: 1px solid rgba(255,255,255,0.08);
  background: rgba(13,17,23,0.55);
  padding: var(--spacing-md);
  box-shadow: 0 20px 55px rgba(0,0,0,0.28);
}
.lab-panel__head{
  display: flex;
  gap: 12px;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
}
.panel-kicker{
  font-size: 0.7rem;
  letter-spacing: 0.18em;
  text-transform: uppercase;
  color: rgba(88,166,255,0.72);
  margin: 0 0 6px;
}
.panel-title{
  margin: 0;
  font-size: 1.2rem;
}
.panel-actions{ display:flex; gap: 8px; flex-wrap: wrap; }

.lab-tabs{
  display: flex;
  gap: 8px;
  margin-top: var(--spacing-md);
  flex-wrap: wrap;
}
.lab-tab{
  border: 1px solid rgba(88,166,255,0.2);
  background: rgba(13,17,23,0.3);
  color: rgba(230,237,243,0.7);
  padding: 6px 12px;
  border-radius: 999px;
  cursor: pointer;
  font-size: 0.7rem;
  letter-spacing: 0.12em;
  text-transform: uppercase;
}
.lab-tab.active{
  border-color: rgba(88,166,255,0.4);
  color: rgba(88,166,255,0.95);
}

.lab-tabpanels{
  margin-top: var(--spacing-md);
}
.lab-tabpanel{ display: none; }
.lab-tabpanel.active{ display: block; }

.field-label{
  display: block;
  font-weight: 600;
  margin-bottom: 6px;
}
.lab-textarea{
  width: 100%;
  background: rgba(13,17,23,0.4);
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 12px;
  padding: 12px;
  color: rgba(230,237,243,0.9);
  font-family: var(--font-mono);
}
.lab-input,
.lab-file{
  width: 100%;
  background: rgba(13,17,23,0.4);
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 12px;
  padding: 10px 12px;
  color: rgba(230,237,243,0.9);
}
.field-row{
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}
.field-row .lab-input{ flex: 1 1 220px; }
.field-actions{ margin-top: 10px; }
.field-hint{
  margin-top: 8px;
  color: rgba(230,237,243,0.55);
  font-size: 0.85rem;
}

.lab-status{
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
  gap: 8px;
  margin-top: var(--spacing-md);
  padding: 12px;
  border-radius: 14px;
  border: 1px solid rgba(88,166,255,0.16);
  background: rgba(13,17,23,0.35);
  font-size: 0.85rem;
}
.status-label{
  display: block;
  color: rgba(88,166,255,0.72);
  font-size: 0.7rem;
  letter-spacing: 0.12em;
  text-transform: uppercase;
}
.status-pill{
  align-self: center;
  justify-self: end;
  padding: 4px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.1);
  background: rgba(13,17,23,0.3);
  text-transform: uppercase;
  letter-spacing: 0.12em;
  font-size: 0.7rem;
}

.lab-alert,
.lab-warning{
  margin-top: 12px;
  padding: 12px;
  border-radius: 12px;
  border: 1px solid rgba(255, 90, 90, 0.3);
  background: rgba(120, 20, 20, 0.2);
  color: rgba(255, 200, 200, 0.9);
  font-size: 0.9rem;
}
.lab-warning{
  border-color: rgba(246, 217, 110, 0.4);
  background: rgba(60, 50, 18, 0.35);
  color: rgba(246, 217, 110, 0.92);
}

.map-panel{
  position: relative;
  border-radius: 18px;
  overflow: hidden;
  border: 1px solid rgba(255,255,255,0.08);
  background: rgba(13,17,23,0.5);
  min-height: 520px;
}
.map{
  width: 100%;
  height: 520px;
}
.info-panel{
  position: absolute;
  right: 16px;
  bottom: 16px;
  max-width: 320px;
  background: rgba(13,17,23,0.82);
  border: 1px solid rgba(88,166,255,0.2);
  border-radius: 14px;
  padding: 12px;
  color: rgba(230,237,243,0.85);
  box-shadow: 0 12px 40px rgba(0,0,0,0.35);
}
.info-title{
  margin: 0 0 6px;
  font-size: 0.85rem;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: rgba(88,166,255,0.8);
}
.info-content{
  margin: 0;
  max-height: 240px;
  overflow: auto;
  font-size: 0.8rem;
  white-space: pre-wrap;
}

.lab-notes{
  margin-top: var(--spacing-xl);
  border-radius: 16px;
  border: 1px solid rgba(255,255,255,0.08);
  background: rgba(13,17,23,0.45);
  padding: var(--spacing-md);
}
.notes-title{
  margin-top: 0;
  font-size: 1.1rem;
}
</style>
